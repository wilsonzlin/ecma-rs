#!/usr/bin/env node

"use strict";

process.chdir(__dirname);

const { readFileSync, writeFileSync } = require("fs");
const { spawnSync } = require("child_process");

const versionSource = "minify-js/Cargo.toml";
const cargoVersionPattern = /^version = "(\d+)\.(\d+)\.(\d+)"\s*$/m;

const parseVersion = (path) => {
  const match = cargoVersionPattern.exec(readFileSync(path, "utf8"));
  if (!match) {
    throw new Error(`Unable to find version in ${path}`);
  }
  return match.slice(1).map((n) => Number.parseInt(n, 10));
};

const bumpType = process.argv[2];
if (!bumpType) {
  throw new Error("Usage: ./version [major|minor|patch]");
}

const versionPart = ["major", "minor", "patch"].indexOf(bumpType.toLowerCase());
if (versionPart === -1) {
  throw new Error("Invalid argument");
}

const currentVersion = parseVersion(versionSource);
const newVersion = currentVersion.slice();

newVersion[versionPart]++;
for (let idx = versionPart + 1; idx < newVersion.length; idx++) {
  newVersion[idx] = 0;
}

const NEW_VERSION = newVersion.join(".");

console.log(`${currentVersion.join(".")} => ${NEW_VERSION}`);

const cmd = (...cfg) => {
  const command = cfg[0];
  const args = cfg.slice(1);
  const maybeOptions = args[args.length - 1];
  const {
    workingDir,
    throwOnBadStatus = true,
    throwOnSignal = true,
    captureStdio = false,
    throwOnStdErr = false,
  } = typeof maybeOptions === "object" ? args.pop() : {};

  const throwErr = (msg) => {
    throw new Error(`${msg}\n  ${command} ${args.join(" ")}`);
  };

  const { status, signal, error, stdout, stderr } = spawnSync(
    command,
    args.map(String),
    {
      cwd: workingDir,
      stdio: [
        "ignore",
        captureStdio ? "pipe" : "inherit",
        captureStdio || throwOnStdErr ? "pipe" : "inherit",
      ],
      encoding: "utf8",
    }
  );
  if (error) {
    throwErr(error.message);
  }
  if (throwOnSignal && signal) {
    throwErr(`Command exited with signal ${signal}`);
  }
  if (throwOnBadStatus && status !== 0) {
    throwErr(`Command exited with status ${status}`);
  }
  if (throwOnStdErr && stderr) {
    throwErr(`stderr: ${stderr}`);
  }
  return { status, signal, stdout, stderr };
};

const replaceInFile = (path, pattern, replacement) => {
  const content = readFileSync(path, "utf8");
  const next = content.replace(pattern, replacement);
  if (next === content) {
    throw new Error(`No changes made to ${path}`);
  }
  writeFileSync(path, next);
};

if (
  cmd("git", "status", "--porcelain", {
    throwOnStdErr: true,
    captureStdio: true,
  }).stdout
) {
  throw new Error("Working directory not clean");
}
const hasRemote =
  cmd("git", "remote", { captureStdio: true }).stdout.trim().length > 0;
if (hasRemote) {
  cmd("git", "pull");
} else {
  console.log("Skipping git pull: no remotes configured");
}

cmd("cargo", "test");

for (const file of [
  "minify-js/Cargo.toml",
  "minify-js-cli/Cargo.toml",
  "minify-js-nodejs/Cargo.toml",
]) {
  replaceInFile(file, cargoVersionPattern, `version = "${NEW_VERSION}"`);
}

replaceInFile(
  "minify-js-nodejs/Cargo.toml",
  /^(minify-js = { version = )"\d+\.\d+\.\d+"/m,
  `$1"${NEW_VERSION}"`
);

replaceInFile(
  "minify-js-nodejs/package.json",
  /^(\s*"version": )"\d+\.\d+\.\d+",\s*$/m,
  `$1"${NEW_VERSION}",`
);

replaceInFile(
  "minify-js/README.md",
  /^(minify-js = )"\d+\.\d+\.\d+"/m,
  `$1"${NEW_VERSION}"`
);

replaceInFile(
  "minify-js/README.md",
  /(static.wilsonl\.in\/minify-js\/(?:bench|cli)\/)\d+\.\d+\.\d+/g,
  `$1${NEW_VERSION}`
);

cmd("cargo", "generate-lockfile");
cmd("cargo", "test", "--workspace", "--locked");

cmd("git", "add", "-A");
cmd("git", "commit", "-m", NEW_VERSION);
cmd("git", "tag", "-a", `v${NEW_VERSION}`, "-m", "");
// minify-js is publishable; CLI and Node bindings are marked publish = false.
cmd("cargo", "publish", "--allow-dirty", "-p", "minify-js");
if (hasRemote) {
  cmd("git", "push", "--follow-tags");
} else {
  console.log("Skipping git push: no remotes configured");
}
