{
  "analysis_date": "2025-11-20",
  "parser_file": "parse-js/src/parse/type_expr.rs",
  "total_functions": 42,
  "total_lines": 1743,
  "ast_file": "parse-js/src/ast/type_expr.rs",
  "ast_total_lines": 427,

  "summary": {
    "entry_points": 3,
    "primary_parsers": 15,
    "helper_parsers": 12,
    "lookahead_predicates": 2,
    "member_parsers": 10
  },

  "categories": {
    "entry_points": {
      "count": 3,
      "description": "Main entry points for type expression parsing",
      "functions": [
        {
          "name": "type_expr",
          "line": 24,
          "visibility": "pub",
          "purpose": "Main entry point for type expressions",
          "delegates_to": "type_union_or_intersection",
          "example": "type T = string | number"
        },
        {
          "name": "type_expr_or_predicate",
          "line": 30,
          "visibility": "pub",
          "purpose": "Parse type expression or type predicate for function return types",
          "handles": ["x is Type", "asserts x", "asserts x is Type", "this is Type"],
          "example": "function foo(x: any): x is string"
        },
        {
          "name": "type_arguments",
          "line": 660,
          "visibility": "pub",
          "purpose": "Parse type arguments in generic instantiation",
          "example": "Foo<T, U, V>"
        }
      ]
    },

    "primary_parsers": {
      "count": 15,
      "description": "Core parsing functions for different type expression forms",
      "functions": [
        {
          "name": "type_union_or_intersection",
          "line": 88,
          "parses": "Union types with lowest precedence",
          "creates_ast": ["TypeExpr::UnionType"],
          "example": "A | B | C",
          "notes": "Handles leading | syntax"
        },
        {
          "name": "type_intersection",
          "line": 117,
          "parses": "Intersection types",
          "creates_ast": ["TypeExpr::IntersectionType"],
          "example": "A & B & C",
          "notes": "Handles leading & syntax"
        },
        {
          "name": "type_conditional",
          "line": 149,
          "parses": "Conditional types",
          "creates_ast": ["TypeExpr::ConditionalType"],
          "example": "T extends U ? X : Y"
        },
        {
          "name": "type_array_or_postfix",
          "line": 177,
          "parses": "Array types and indexed access types",
          "creates_ast": ["TypeExpr::ArrayType", "TypeExpr::IndexedAccessType"],
          "example": "T[] or T[K]"
        },
        {
          "name": "type_primary",
          "line": 226,
          "parses": "Primary type expressions (primitives, keywords, literals)",
          "creates_ast": [
            "TypeExpr::Any", "TypeExpr::Unknown", "TypeExpr::Never", "TypeExpr::Void",
            "TypeExpr::String", "TypeExpr::Number", "TypeExpr::Boolean", "TypeExpr::BigInt",
            "TypeExpr::Symbol", "TypeExpr::UniqueSymbol", "TypeExpr::Object",
            "TypeExpr::Null", "TypeExpr::Undefined", "TypeExpr::ThisType",
            "TypeExpr::LiteralType", "TypeExpr::TupleType", "TypeExpr::TypeReference"
          ],
          "example": "string, number, boolean, etc.",
          "notes": "Very large function (~290 lines) handling many cases"
        },
        {
          "name": "type_reference",
          "line": 519,
          "parses": "Type references with optional generic arguments",
          "creates_ast": ["TypeExpr::TypeReference"],
          "example": "Foo<T, U> or A.B.C"
        },
        {
          "name": "type_query",
          "line": 674,
          "parses": "typeof type queries",
          "creates_ast": ["TypeExpr::TypeQuery"],
          "example": "typeof foo or typeof import('./mod')",
          "notes": "Supports typeof import(...)"
        },
        {
          "name": "keyof_type",
          "line": 695,
          "parses": "keyof operator",
          "creates_ast": ["TypeExpr::KeyOfType"],
          "example": "keyof T"
        },
        {
          "name": "infer_type",
          "line": 709,
          "parses": "infer type in conditional types",
          "creates_ast": ["TypeExpr::InferType"],
          "example": "infer R or infer R extends U",
          "notes": "Supports extends clause on infer"
        },
        {
          "name": "import_type",
          "line": 732,
          "parses": "import() type expressions",
          "creates_ast": ["TypeExpr::ImportType"],
          "example": "import('./module').Type<T>"
        },
        {
          "name": "object_type",
          "line": 768,
          "parses": "Object type literals or mapped types",
          "creates_ast": ["TypeExpr::ObjectType", "TypeExpr::MappedType"],
          "example": "{ x: T } or { [K in keyof T]: V }",
          "notes": "Disambiguates between object types and mapped types"
        },
        {
          "name": "tuple_type",
          "line": 1157,
          "parses": "Tuple types",
          "creates_ast": ["TypeExpr::TupleType"],
          "example": "[T, U, ...V[]]",
          "notes": "Supports labeled and rest elements"
        },
        {
          "name": "paren_or_function_type",
          "line": 1227,
          "parses": "Parenthesized types or function types",
          "creates_ast": ["TypeExpr::ParenthesizedType", "TypeExpr::FunctionType"],
          "example": "(string) or (x: T) => U",
          "notes": "Uses lookahead to disambiguate"
        },
        {
          "name": "try_function_type",
          "line": 1318,
          "parses": "Function types with optional type parameters",
          "creates_ast": ["TypeExpr::FunctionType"],
          "example": "<T>(x: T) => U"
        },
        {
          "name": "constructor_type",
          "line": 1347,
          "parses": "Constructor types",
          "creates_ast": ["TypeExpr::ConstructorType"],
          "example": "new (x: T) => U",
          "notes": "Handles abstract new syntax"
        },
        {
          "name": "template_literal_type",
          "line": 1551,
          "parses": "Template literal types",
          "creates_ast": ["TypeExpr::TemplateLiteralType"],
          "example": "`foo${T}bar`"
        }
      ]
    },

    "helper_parsers": {
      "count": 12,
      "description": "Helper functions that parse sub-components",
      "functions": [
        {
          "name": "parse_mapped_type_modifier",
          "line": 11,
          "purpose": "Parse +/- modifiers in mapped types",
          "example": "readonly, +readonly, -readonly, ?, +?, -?"
        },
        {
          "name": "parse_type_entity_name",
          "line": 543,
          "purpose": "Parse qualified names (A.B.C)",
          "returns": "TypeEntityName"
        },
        {
          "name": "require_type_identifier",
          "line": 556,
          "purpose": "Parse identifier or contextual keyword in type position",
          "returns": "String"
        },
        {
          "name": "type_property_key",
          "line": 904,
          "purpose": "Parse property keys in type members",
          "returns": "TypePropertyKey"
        },
        {
          "name": "tuple_element",
          "line": 1185,
          "purpose": "Parse single tuple element",
          "returns": "TypeTupleElement",
          "notes": "Handles labeled, optional, and rest elements"
        },
        {
          "name": "function_type_parameters",
          "line": 1376,
          "purpose": "Parse function type parameter lists",
          "returns": "Vec<TypeFunctionParameter>",
          "notes": "Handles this parameter"
        },
        {
          "name": "function_type_parameter",
          "line": 1418,
          "purpose": "Parse single function type parameter",
          "returns": "TypeFunctionParameter",
          "notes": "Handles rest, optional, accessibility modifiers"
        },
        {
          "name": "type_parameters",
          "line": 1493,
          "visibility": "pub",
          "purpose": "Parse type parameter lists <T, U>",
          "returns": "Vec<TypeParameter>"
        },
        {
          "name": "type_parameter",
          "line": 1507,
          "purpose": "Parse single type parameter",
          "returns": "TypeParameter",
          "notes": "Handles const, variance (in/out), extends, default"
        },
        {
          "name": "mapped_type",
          "line": 1601,
          "visibility": "pub",
          "purpose": "Parse mapped type (standalone)",
          "creates_ast": ["TypeExpr::MappedType"]
        },
        {
          "name": "mapped_type_body",
          "line": 1646,
          "purpose": "Parse mapped type body (after opening brace consumed)",
          "creates_ast": ["TypeExpr::MappedType"],
          "notes": "Used by object_type after disambiguation"
        },
        {
          "name": "mapped_type_member",
          "line": 1692,
          "purpose": "Parse mapped type as object member",
          "returns": "TypeMember::MappedProperty"
        }
      ]
    },

    "lookahead_predicates": {
      "count": 2,
      "description": "Functions that look ahead to disambiguate syntax",
      "functions": [
        {
          "name": "is_start_of_type_arguments",
          "line": 580,
          "visibility": "pub",
          "purpose": "Disambiguate < for generics vs less-than operator",
          "notes": "Uses checkpoint/restore for speculation"
        },
        {
          "name": "looks_like_function_type",
          "line": 1251,
          "purpose": "Quick lookahead to check for => after params",
          "notes": "Prevents exponential backtracking on nested parens"
        }
      ]
    },

    "member_parsers": {
      "count": 10,
      "description": "Functions that parse type members (for object types and interfaces)",
      "functions": [
        {
          "name": "type_members",
          "line": 817,
          "visibility": "pub",
          "purpose": "Parse list of type members",
          "returns": "Vec<TypeMember>"
        },
        {
          "name": "type_member",
          "line": 833,
          "purpose": "Parse single type member",
          "returns": "TypeMember",
          "notes": "Disambiguates property/method/call/construct/index/accessor/mapped"
        },
        {
          "name": "property_signature",
          "line": 931,
          "purpose": "Parse property signature",
          "returns": "TypeMember::Property"
        },
        {
          "name": "method_signature",
          "line": 962,
          "purpose": "Parse method signature",
          "returns": "TypeMember::Method"
        },
        {
          "name": "call_signature",
          "line": 1005,
          "purpose": "Parse call signature",
          "returns": "TypeCallSignature"
        },
        {
          "name": "construct_signature",
          "line": 1033,
          "purpose": "Parse constructor signature",
          "returns": "TypeMember::Constructor"
        },
        {
          "name": "index_signature",
          "line": 1069,
          "purpose": "Parse index signature",
          "returns": "TypeMember::IndexSignature"
        },
        {
          "name": "get_accessor_signature",
          "line": 1092,
          "purpose": "Parse get accessor signature",
          "returns": "TypeMember::GetAccessor"
        },
        {
          "name": "set_accessor_signature",
          "line": 1122,
          "purpose": "Parse set accessor signature",
          "returns": "TypeMember::SetAccessor",
          "notes": "Error recovery for empty parameter list"
        },
        {
          "name": "mapped_type_member",
          "line": 1692,
          "purpose": "Parse mapped type member",
          "returns": "TypeMember::MappedProperty"
        }
      ]
    }
  },

  "code_quality_notes": {
    "todos": 0,
    "fixmes": 0,
    "unimplemented": 0,
    "panics": 0,
    "largest_function": {
      "name": "type_primary",
      "approximate_lines": 290,
      "note": "Handles many primitive types and keywords in large match statement"
    },
    "complex_functions": [
      {
        "name": "is_start_of_type_arguments",
        "reason": "Complex lookahead logic with speculation"
      },
      {
        "name": "type_member",
        "reason": "Many different type member forms to disambiguate"
      },
      {
        "name": "looks_like_function_type",
        "reason": "Manually scans for matching delimiters"
      }
    ],
    "error_recovery": [
      {
        "location": "type_primary:501-511",
        "handles": "Private names in type expressions (e.g., C[#bar])"
      },
      {
        "location": "function_type_parameter:1423-1429",
        "handles": "Accessibility modifiers in type signatures"
      },
      {
        "location": "function_type_parameter:1452-1475",
        "handles": "Default values in type signatures"
      },
      {
        "location": "set_accessor_signature:1130-1141",
        "handles": "Setters with no parameter (creates synthetic parameter)"
      }
    ]
  }
}
