{
  "analysis_date": "2025-11-20",
  "total_ast_nodes": 33,
  "parsed_nodes": 33,
  "orphaned_nodes": 0,
  "coverage_percentage": 100.0,

  "summary": {
    "finding": "ALL TypeExpr AST nodes are being parsed",
    "status": "Complete coverage - no orphaned nodes found",
    "verification": "Searched all parser files for TypeExpr:: constructions"
  },

  "node_coverage": {
    "Any": {
      "status": "parsed",
      "parser_function": "type_primary",
      "parser_line": 231,
      "token_trigger": "TT::KeywordAny",
      "example": "type T = any",
      "occurrences": 3
    },

    "Unknown": {
      "status": "parsed",
      "parser_function": "type_primary",
      "parser_line": 237,
      "token_trigger": "TT::KeywordUnknown",
      "example": "type T = unknown"
    },

    "Never": {
      "status": "parsed",
      "parser_function": "type_primary",
      "parser_line": 243,
      "token_trigger": "TT::KeywordNever",
      "example": "type T = never"
    },

    "Void": {
      "status": "parsed",
      "parser_function": "type_primary",
      "parser_line": 249,
      "token_trigger": "TT::KeywordVoid",
      "example": "type T = void"
    },

    "String": {
      "status": "parsed",
      "parser_function": "type_primary",
      "parser_line": 255,
      "token_trigger": "TT::KeywordStringType",
      "example": "type T = string"
    },

    "Number": {
      "status": "parsed",
      "parser_function": "type_primary",
      "parser_line": 261,
      "token_trigger": "TT::KeywordNumberType",
      "example": "type T = number"
    },

    "Boolean": {
      "status": "parsed",
      "parser_function": "type_primary",
      "parser_line": 267,
      "token_trigger": "TT::KeywordBooleanType",
      "example": "type T = boolean"
    },

    "BigInt": {
      "status": "parsed",
      "parser_function": "type_primary",
      "parser_line": 273,
      "token_trigger": "TT::KeywordBigIntType",
      "example": "type T = bigint"
    },

    "Symbol": {
      "status": "parsed",
      "parser_function": "type_primary",
      "parser_line": 279,
      "token_trigger": "TT::KeywordSymbolType",
      "example": "type T = symbol"
    },

    "UniqueSymbol": {
      "status": "parsed",
      "parser_function": "type_primary",
      "parser_line": 285,
      "token_trigger": "TT::KeywordUnique followed by TT::KeywordSymbolType",
      "example": "type T = unique symbol",
      "notes": "Requires 'unique symbol' keyword combination"
    },

    "Object": {
      "status": "parsed",
      "parser_function": "type_primary",
      "parser_line": 299,
      "token_trigger": "TT::KeywordObjectType",
      "example": "type T = object"
    },

    "Null": {
      "status": "parsed",
      "parser_function": "type_primary",
      "parser_line": 311,
      "token_trigger": "TT::LiteralNull",
      "example": "type T = null"
    },

    "Undefined": {
      "status": "parsed",
      "parser_function": "type_primary",
      "parser_line": 305,
      "token_trigger": "TT::KeywordUndefinedType",
      "example": "type T = undefined"
    },

    "ThisType": {
      "status": "parsed",
      "parser_function": "type_primary",
      "parser_line": 394,
      "token_trigger": "TT::KeywordThis",
      "example": "type T = this",
      "notes": "Also used in type predicates"
    },

    "TypeReference": {
      "status": "parsed",
      "parser_function": ["type_primary", "type_reference"],
      "parser_line": [319, 519],
      "token_trigger": "TT::Identifier or contextual keywords",
      "example": "type T = Foo<Bar>",
      "notes": "Also created for error recovery (private names)",
      "occurrences": 3
    },

    "LiteralType": {
      "status": "parsed",
      "parser_function": "type_primary",
      "parser_line": [439, 445, 451, 463, 475, 481, 487],
      "token_trigger": "TT::LiteralString, TT::LiteralNumber, TT::LiteralBigInt, TT::LiteralTrue, TT::LiteralFalse, TT::Hyphen",
      "example": "type T = 'foo' | 42 | true | -123",
      "notes": "Handles string, number, bigint, boolean literals including negative numbers",
      "occurrences": 7
    },

    "ArrayType": {
      "status": "parsed",
      "parser_function": ["type_array_or_postfix", "type_primary"],
      "parser_line": [193, 367],
      "token_trigger": "TT::BracketOpen followed by TT::BracketClose (T[]) or readonly T[]",
      "example": "type T = string[] or readonly string[]",
      "notes": "Two creation paths: postfix and readonly prefix",
      "occurrences": 2
    },

    "TupleType": {
      "status": "parsed",
      "parser_function": ["tuple_type", "type_primary"],
      "parser_line": [1177, 349],
      "token_trigger": "TT::BracketOpen or readonly [",
      "example": "type T = [string, number] or readonly [T, U]",
      "notes": "Supports readonly modifier, named elements, rest elements",
      "occurrences": 2
    },

    "UnionType": {
      "status": "parsed",
      "parser_function": "type_union_or_intersection",
      "parser_line": 113,
      "token_trigger": "TT::Bar between types",
      "example": "type T = A | B | C",
      "notes": "Handles leading | syntax"
    },

    "IntersectionType": {
      "status": "parsed",
      "parser_function": "type_intersection",
      "parser_line": 144,
      "token_trigger": "TT::Ampersand between types",
      "example": "type T = A & B & C",
      "notes": "Handles leading & syntax"
    },

    "FunctionType": {
      "status": "parsed",
      "parser_function": ["try_function_type", "paren_or_function_type"],
      "parser_line": [1343, 1246],
      "token_trigger": "( followed by => or <T>(...) =>",
      "example": "type T = (x: string) => number or <T>(x: T) => T"
    },

    "ConstructorType": {
      "status": "parsed",
      "parser_function": "constructor_type",
      "parser_line": 1372,
      "token_trigger": "TT::KeywordNew or abstract new",
      "example": "type T = new (x: string) => Foo",
      "notes": "Handles abstract constructor syntax"
    },

    "ObjectType": {
      "status": "parsed",
      "parser_function": "object_type",
      "parser_line": 813,
      "token_trigger": "TT::BraceOpen (non-mapped type)",
      "example": "type T = { x: string; y: number }",
      "notes": "Disambiguates from mapped types"
    },

    "ParenthesizedType": {
      "status": "parsed",
      "parser_function": "paren_or_function_type",
      "parser_line": 1242,
      "token_trigger": "TT::ParenthesisOpen without =>",
      "example": "type T = (string)",
      "notes": "Uses lookahead to avoid parsing as function type"
    },

    "TypeQuery": {
      "status": "parsed",
      "parser_function": "type_query",
      "parser_line": 691,
      "token_trigger": "TT::KeywordTypeof",
      "example": "type T = typeof foo or typeof import('./mod')",
      "notes": "Supports typeof import(...) syntax"
    },

    "KeyOfType": {
      "status": "parsed",
      "parser_function": "keyof_type",
      "parser_line": 705,
      "token_trigger": "TT::KeywordKeyof",
      "example": "type T = keyof SomeType"
    },

    "IndexedAccessType": {
      "status": "parsed",
      "parser_function": "type_array_or_postfix",
      "parser_line": 215,
      "token_trigger": "TT::BracketOpen with index type (T[K])",
      "example": "type T = MyType[PropertyName]"
    },

    "ConditionalType": {
      "status": "parsed",
      "parser_function": "type_conditional",
      "parser_line": 172,
      "token_trigger": "TT::KeywordExtends in type expression",
      "example": "type T = A extends B ? C : D"
    },

    "InferType": {
      "status": "parsed",
      "parser_function": "infer_type",
      "parser_line": 728,
      "token_trigger": "TT::KeywordInfer",
      "example": "type T = X extends (infer R)[] ? R : never",
      "notes": "Supports extends constraint on inferred type"
    },

    "MappedType": {
      "status": "parsed",
      "parser_function": ["mapped_type_body", "mapped_type"],
      "parser_line": [1688, 1642],
      "token_trigger": "{ followed by [K in ...",
      "example": "type T = { [K in keyof Foo]: Foo[K] }",
      "notes": "Supports readonly/optional modifiers and 'as' clause for key remapping",
      "occurrences": 2
    },

    "TemplateLiteralType": {
      "status": "parsed",
      "parser_function": "template_literal_type",
      "parser_line": 1596,
      "token_trigger": "TT::LiteralTemplatePartString",
      "example": "type T = `foo${string}bar`"
    },

    "TypePredicate": {
      "status": "parsed",
      "parser_function": "type_expr_or_predicate",
      "parser_line": [62, 72],
      "token_trigger": "identifier/this followed by 'is' or 'asserts'",
      "example": "x is Type, asserts x, asserts x is Type",
      "occurrences": 2
    },

    "ImportType": {
      "status": "parsed",
      "parser_function": "import_type",
      "parser_line": 763,
      "token_trigger": "TT::KeywordImport",
      "example": "type T = import('./module').SomeType<T>"
    }
  },

  "orphaned_nodes": {
    "count": 0,
    "analysis": "All 33 TypeExpr variants defined in the AST are created by the parser",
    "verification_method": "Grepped all parser files for 'TypeExpr::' constructions and compared with AST enum definition",
    "nodes": []
  },

  "parser_gaps_analysis": {
    "missing_parsers": 0,
    "incomplete_parsers": 0,
    "notes": [
      "Parser has complete coverage of all defined AST nodes",
      "All modern TypeScript features represented in AST are parsed",
      "No dead AST nodes found"
    ]
  },

  "special_cases": {
    "error_recovery": [
      {
        "node": "TypeReference",
        "case": "Private names in type position",
        "line": 503,
        "example": "const x: C[#bar] = 3",
        "semantic_validity": "Invalid but syntactically accepted"
      }
    ],
    "disambiguation": [
      {
        "syntax": "< in type position",
        "disambiguator": "is_start_of_type_arguments",
        "line": 580,
        "resolves": "Generic type arguments vs less-than operator"
      },
      {
        "syntax": "( in type position",
        "disambiguator": "looks_like_function_type",
        "line": 1251,
        "resolves": "Function type vs parenthesized type"
      },
      {
        "syntax": "{ [ in type position",
        "disambiguator": "object_type lookahead",
        "line": 772,
        "resolves": "Mapped type vs object type with index signature"
      }
    ],
    "multiple_creation_sites": [
      {
        "node": "TypeReference",
        "sites": [
          "type_primary:319 (identifier)",
          "type_reference:539 (with type args)",
          "type_primary:510 (error recovery)"
        ]
      },
      {
        "node": "ArrayType",
        "sites": [
          "type_array_or_postfix:203 (postfix [])",
          "type_primary:374 (readonly T[])"
        ]
      },
      {
        "node": "TupleType",
        "sites": [
          "tuple_type:1181 (standard [T, U])",
          "type_primary:350 (readonly [T, U])"
        ]
      },
      {
        "node": "MappedType",
        "sites": [
          "mapped_type:1642 (standalone)",
          "mapped_type_body:1688 (from object_type)"
        ]
      },
      {
        "node": "LiteralType",
        "sites": [
          "type_primary:443 (string literal)",
          "type_primary:449 (number literal)",
          "type_primary:462 (negative number)",
          "type_primary:470 (negative bigint)",
          "type_primary:479 (bigint literal)",
          "type_primary:485 (true literal)",
          "type_primary:491 (false literal)"
        ]
      }
    ]
  },

  "advanced_features_support": {
    "const_type_parameters": {
      "status": "parsed",
      "parser_function": "type_parameter",
      "line": 1510,
      "example": "<const T extends readonly any[]>"
    },
    "variance_annotations": {
      "status": "parsed",
      "parser_function": "type_parameter",
      "line": 1514,
      "example": "<in T, out U, in out V>"
    },
    "infer_extends": {
      "status": "parsed",
      "parser_function": "infer_type",
      "line": 715,
      "example": "infer R extends SomeConstraint"
    },
    "mapped_as_clause": {
      "status": "parsed",
      "parser_function": "mapped_type",
      "line": 1614,
      "example": "{ [K in keyof T as NewKey]: V }"
    },
    "typeof_import": {
      "status": "parsed",
      "parser_function": "type_query",
      "line": 679,
      "example": "typeof import('./module')"
    },
    "abstract_constructor": {
      "status": "parsed",
      "parser_function": "constructor_type (via type_primary)",
      "line": 425,
      "example": "abstract new () => T"
    },
    "this_type_predicate": {
      "status": "parsed",
      "parser_function": "type_expr_or_predicate",
      "line": 43,
      "example": "this is Type"
    },
    "asserts_predicate": {
      "status": "parsed",
      "parser_function": "type_expr_or_predicate",
      "line": 36,
      "example": "asserts x is Type"
    }
  }
}
